False Sharing 定义

False Sharing（伪共享） 是一种典型的多线程性能问题。它并不是内存正确性错误，而是 由于缓存行（cache line）共享导致的性能下降。

在现代 CPU 中，缓存是按 缓存行（通常 64 字节） 为基本单位进行读写的。如果两个（或多个）线程操作的变量恰好落在同一个缓存行上，即使它们逻辑上没有关系，CPU 缓存一致性协议（如 MESI）也会认为这些线程在“共享”同一块数据。
结果就是：

一个线程修改了该缓存行中的某个变量 → 其他线程的缓存行副本被 强制失效；

另一个线程需要再次从内存/其他 CPU 核心拉取最新的缓存行；

导致缓存频繁失效、总线流量增大，性能急剧下降。

因此，False Sharing 本质上是：
“不同线程操作了不同的变量，但这些变量落在同一个缓存行里，从而产生了缓存一致性伪冲突”。

Java 中的 False Sharing

在 Java 中，False Sharing 通常出现在以下场景：

多线程独立计数器
每个线程维护一个独立的 long 计数器，但由于 long 只占 8 字节，而一个缓存行有 64 字节，导致多个计数器紧密排布在同一个缓存行中
```java
public class Counter {
    public volatile long value = 0;
}
```
如果多个 Counter 对象放在数组中，它们往往连续分布在内存中，很可能共享缓存行。

环形队列（RingBuffer）/Disruptor
高性能队列结构往往需要频繁更新 head/tail 索引，这两个字段若在同一缓存行上，会造成不同线程之间的伪共享。

解决方案

Java 提供了几种方式来避免 False Sharing：

缓存行填充（Padding）
通过人为在字段前后增加“无用字段”来撑满一个缓存行，确保关键字段独占一行。
```java
public class PaddedCounter {
    // 前置填充（避免和前面对象字段共享行）
    private long p1, p2, p3, p4, p5, p6, p7;
    
    public volatile long value = 0;
    
    // 后置填充（避免和后面对象字段共享行）
    private long p9, p10, p11, p12, p13, p14, p15;
}
```

缺点：浪费内存，但换取性能。

@Contended 注解（Java 8+，需 -XX:-RestrictContended）
JVM 提供了 @sun.misc.Contended 注解（Java 9 移到 jdk.internal.vm.annotation.Contended），用于指示 JIT 编译器在对象布局时给字段填充缓存行。
```java
import jdk.internal.vm.annotation.Contended;

public class SafeCounter {
    @Contended
    public volatile long value = 0;
}
```
默认填充 128 字节（两个缓存行，避免跨行问题）。

需要 JVM 参数开启：
-XX:-RestrictContended




